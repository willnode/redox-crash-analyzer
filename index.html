<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Redox Crash Analyzer</title>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --text-color: #d4d4d4;
      --primary-color: #569cd6;
      --input-bg: #252526;
      --border-color: #3e3e42;
      --error-color: #f48771;
      --success-color: #6a9955;
      --highlight-bg: #5a5a22;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 2em;
    }

    #app {
      display: grid;
      grid-template-columns: 40% 1fr;
      gap: 2em;
      height: calc(100vh - 4em);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    h1,
    h2 {
      color: var(--primary-color);
      margin-top: 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5em;
    }

    label {
      font-weight: bold;
      color: #ccc;
    }

    textarea,
    .dir-picker,
    input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      background: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 0.5em;
      font-family: "Fira Code", monospace;
    }

    textarea {
      resize: vertical;
      min-height: calc(30vh - 50px);
    }

    .dir-picker {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dir-picker span {
      opacity: 0.7;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 0.8em 1.2em;
      border-radius: 4px;
      font-size: 1em;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #408ac9;
    }

    button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }

    .output-view {
      display: flex;
      flex-direction: column;
      background: var(--input-bg);
      border-radius: 4px;
      overflow: hidden;
    }

    .status {
      padding: 1em;
      text-align: center;
      border-bottom: 1px solid var(--border-color);
    }

    .jump-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      padding: 0.5em 1em;
      border-bottom: 1px solid var(--border-color);
      background: #2a2a2d;
    }

    .jump-input-group {
      display: flex;
      gap: 0.5em;
    }

    .symbol-info {
      margin-top: 0.5em;
      color: #6a9955;
      font-family: "Fira Code", monospace;
      font-size: 0.9em;
    }

    .error {
      color: var(--error-color);
    }

    .success {
      color: var(--success-color);
    }

    pre {
      flex-grow: 1;
      margin: 0;
      padding: 1em;
      white-space: pre;
      overflow-x: auto;
      font-family: "Fira Code", "Courier New", monospace;
      color: #9cdcfe;
    }

    .highlight {
      background-color: var(--highlight-bg);
      display: block;
    }

    .offset {
      color: #6a9955;
    }

    .bytes {
      color: #b5cea8;
    }

    .mnemonic {
      color: #c586c0;
      font-weight: bold;
    }

    #fault-stack-div {
      display: flex;
    }

    #fault-stack-div>div {
      flex-grow: 1;
    }

    .call-stack-list {
      display: flex;
      flex-direction: column;
      margin: 0 5px;
    }

    .call-stack-list>div {
      display: flex;
      flex-direction: column;
    }

    .call-stack-list button {
      background: inherit;
      text-align: center;
      border-bottom: 2px solid #a0a0a0;
      color: gray;
    }

    .call-stack-list button.active {
      color: white;
      border-bottom: 2px solid #408ac9;
    }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/@alexaltea/capstone-js@3.0.5/dist/capstone.min.js"></script>
</head>

<body>

  <div id="app">
    <div class="controls">
      <h1>Redox Crash Analyzer</h1>
      <div id="fault-stack-div">
        <div>
          <label for="fault-log">1. Page Fault Message</label>
          <textarea id="fault-log" v-model="faultLog"
            placeholder="Paste kernel log with RIP address here..."></textarea>
        </div>
        <div v-if="callStacks.length > 0" class="call-stack-list">
          <label for="sysroot-dir">4. Call Stack</label>
          <div v-for="stack in callStacks">
            <button @click="() => jumpToStack(stack)" :class="{ active: stack == jumpAddress }">{{ stack }}</button>
          </div>
        </div>
      </div>
      <div>
        <label for="ld-debug-log">2. LD_DEBUG Output</label>
        <textarea id="ld-debug-log" v-model="ldDebugLog"
          placeholder="Paste 'env LD_DEBUG=all ...' output here..."></textarea>
      </div>
      <div>
        <label for="sysroot-dir">3. Sysroot Directory</label>
        <div class="dir-picker">
          <span>{{ sysrootDirHandle ? sysrootDirHandle.name : 'No directory selected' }}</span>
          <button @click="selectDirectory">Select Sysroot</button>
        </div>
        <small style="opacity: 0.6;">Select the root folder containing the binaries (hint: run make mount).</small>
      </div>
      <button @click="analyzeCrash" :disabled="isLoading || !isReady">
        {{ isLoading ? 'Analyzing...' : 'Analyze Crash' }}
      </button>
    </div>

    <div class="output-view">
      <div class="status">
        <div v-if="error" class="error">{{ error }}</div>
        <div v-else-if="successMessage" class="success">{{ successMessage }}</div>
        <div v-else>Disassembly Output</div>
      </div>

      <div class="jump-controls" v-if="analysisData">
        <div class="jump-input-group">
          <input type="text" v-model="jumpAddress" placeholder="0x..." @keyup.enter="jumpToAddress" />
          <button @click="jumpToAddress">Jump</button>
        </div>
        <div class="symbol-info" v-if="currentSymbolName">{{ currentSymbolName }}</div>
        <div class="symbol-info" v-if="currentSymbolName2">{{ currentSymbolName2 }}</div>
      </div>

      <pre v-html="disassemblyOutput"></pre>
    </div>
  </div>

  <script type="module">
    import * as elfist from 'https://unpkg.com/@wokwi/elfist@1.0.2/dist/esm/index.js';
    const { createApp, ref, computed, nextTick } = Vue;

    // --- Configuration for the disassembly window ---
    const LINES_BEFORE = 200;
    const LINES_AFTER = 200;

    // How many extra bytes to read before the target address to ensure we can disassemble `LINES_BEFORE` instructions.
    // Variable-length instructions mean we have to guess. 10 bytes per instruction is a safe overestimate.
    const CONTEXT_BYTES = LINES_BEFORE * 10;

    const alignUp = (number, alignment) => {
      return (number + alignment - 1) & -alignment;
    };
    const alignDown = (number, alignment) => {
      return number - (number % alignment);
    };

    function waitForNextFrame() {
      return new Promise(resolve => {
        requestAnimationFrame(resolve);
      });
    }

    createApp({
      setup() {
        const faultLog = ref(window.sessionStorage.faultLog || '');
        const ldDebugLog = ref(window.sessionStorage.ldDebugLog || '');
        const sysrootDirHandle = ref(null);
        const disassemblyOutput = ref('Enter the Page fault message and click "Start Analyze"');
        const isLoading = ref(false);
        const error = ref(null);
        const successMessage = ref(null);

        const isReady = computed(() => faultLog.value && sysrootDirHandle.value);

        const analysisData = ref(null);
        const jumpAddress = ref('');
        const currentSymbolName = ref('');
        const currentSymbolName2 = ref('');
        const callStacks = ref([]);

        const updateSymbolInfo = (ripNum) => {
          if (!analysisData.value?.symbols) {
            currentSymbolName.value = '';
            currentSymbolName2.value = '';
            return;
          }
          const { symbols, runtimeModuleOffset, pathModule } = analysisData.value;

          for (const sym of symbols) {
            if (!sym.value || !sym.size) continue; // skip broken

            const symStart = Number(runtimeModuleOffset) + sym.value;
            const symEnd = symStart + sym.size;

            if (ripNum >= symStart && ripNum < symEnd) {
              const offset = ripNum - symStart;
              currentSymbolName.value = `Symbol: ${sym.name} (0x${symStart.toString(16)}:0x${symEnd.toString(16)}) +0x${offset.toString(16)}`;
              currentSymbolName2.value = `gdb -batch -ex 'file ${pathModule}' -ex 'disassemble 0x${symStart.toString(16)}, 0x${symEnd.toString(16)}'`;
              return { start: symStart, end: symEnd, size: sym.size };
            }
          }
          currentSymbolName.value = 'Symbol: <not found in table>';
          currentSymbolName.value2 = '';
        };

        const selectDirectory = async () => {
          try {
            sysrootDirHandle.value = await window.showDirectoryPicker();
            error.value = null;
          } catch (err) {
            console.error("Error selecting directory:", err);
            error.value = "Failed to select directory. This feature only works on Chromium-based browsers.";
          }
        };

        const findFileInDirectory = async (dirHandle, path) => {
          if (path.startsWith('lib')) {
            path = 'usr/' + path;
          }
          const parts = path.split('/').filter(p => p && p !== '.');
          let currentHandle = dirHandle;
          for (const part of parts.slice(0, -1)) {
            currentHandle = await currentHandle.getDirectoryHandle(part, { create: false });
          }
          const fileName = parts[parts.length - 1];
          try {
            return (await currentHandle.getFileHandle(fileName, { create: false }));
          } catch (error) {
            // this is probably pointing to a symlink, but symlink is not supported here
            let files = await Array.fromAsync(currentHandle.entries());
            let file = files.find(x => x[0].startsWith(fileName));
            if (file) {
              return file[1];
            }
            throw new Error(`Can't find file ${path}.\n Chrome API does not support symlink. You might want to\n alter the path in LD_DEBUG or page fault input to fix this issue.`);
          }
        };

        /** @param {BigInteger} targetAddrBigInt  */
        const renderDisassemblyWindow = async (targetAddrBigInt) => {
          // Parse memory map from LD_DEBUG
          const rip = targetAddrBigInt;
          const ripNum = Number(targetAddrBigInt);
          const memoryMap = [];
          const ldLines = ldDebugLog.value.split('\n');

          let lastFoundPath = null;
          const foundAtRegex = /found at '(.*?)'/;
          const loadingObjectRegex = /loading object: (.*?) at (0x[0-9a-fA-F]+):(0x[0-9a-fA-F]+) \(pie: (\w+)\)/;

          for (const line of ldLines) {
            const foundMatch = line.match(foundAtRegex);
            if (foundMatch) {
              // Remember the full path when we see "found at..."
              lastFoundPath = foundMatch[1];
              continue; // This line is processed, move to the next
            }

            const loadingMatch = line.match(loadingObjectRegex);
            if (loadingMatch) {
              let objectPath = loadingMatch[1].split("'").join("").trim();

              // If the path from "loading object:" is not absolute (i.e., it's a short name),
              // then we must use the full path we remembered from the previous line.
              if (!objectPath.startsWith('/') && lastFoundPath) {
                objectPath = lastFoundPath;
              }

              // Only add to the map if we have a valid path
              if (objectPath) {
                memoryMap.push({
                  path: objectPath,
                  start: BigInt(loadingMatch[2]),
                  end: BigInt(loadingMatch[3]),
                  static: loadingMatch[4] === "false",
                });
              }

              // Reset the remembered path so it's not accidentally reused.
              lastFoundPath = null;
            }
          }

          let staticBinary = false;
          if (memoryMap.length === 0) {
            // assume this is static binary
            const nameRegex = /NAME ([\w\/\-]+)/;
            const nameFound = faultLog.value.match(nameRegex);
            if (nameFound) {
              const objectPath = nameFound[1];
              memoryMap.push({
                path: objectPath,
                start: BigInt(0),
                end: rip, // don't bother getting a correct value
                static: true,
              });
              staticBinary = true;
            }
          }

          if (memoryMap.length === 0) throw new Error("Could not parse any loaded objects from LD_DEBUG output.");
          disassemblyOutput.value += `\nParsed ${memoryMap.length} loaded objects.`;

          // Find the faulting module
          const faultingModule = memoryMap.find(m => rip >= m.start && rip <= m.end);
          if (!faultingModule) throw new Error(`Could not find a module containing the RIP address 0x${rip.toString(16)}.\n The code maybe loaded from mmap in the application.`);
          disassemblyOutput.value += `\nRIP is inside module: ${faultingModule.path}`;

          // Calculate offset
          const runtimeModuleOffset = faultingModule.start * BigInt(faultingModule.static ? 0 : 1); // non PIE object don't remap start offset, according to relibc
          const ripOffset = rip - runtimeModuleOffset;
          disassemblyOutput.value += `\nCalculated offset: 0x${ripOffset.toString(16)}`;
          if (faultingModule.static) {
            disassemblyOutput.value += " (unchanged because it's not PIE)";
          }

          // Find the file in the selected sysroot directory
          let pathModule = (faultingModule.path + '').replace(/^\//, ''); // Remove leading '/'

          disassemblyOutput.value += `\nSearching for ${pathModule} in sysroot...`;
          const fileHandle = await findFileInDirectory(sysrootDirHandle.value, pathModule);
          const file = await fileHandle.getFile();
          disassemblyOutput.value += `\nFound file: ${file.name}`;

          // Read and disassemble the file using elfist
          const arrayBuffer = await file.arrayBuffer();
          const elf = new elfist.ELFParser(new Uint8Array(arrayBuffer));

          // get ALL PT_LOAD segments
          const executableSegments = elf.program.filter(ph => ph.type === 1);

          if (executableSegments.length === 0) {
            throw new Error("Could not find any executable PT_LOAD segments in the ELF file.");
          }

          let mmapLayout = null, containingSegment = null;
          for (const segment of executableSegments) {
            let { align, vaddr, memsz, offset } = segment;
            // offset is usually zero on Redox GCC
            offset = alignDown(offset, align);
            memsz = alignUp(memsz + vaddr % align, align);
            vaddr = alignDown(vaddr, align);

            disassemblyOutput.value += `\nLoaded code ${vaddr.toString(16)}-${(vaddr + memsz).toString(16)}`;
            if (ripOffset >= vaddr && ripOffset < vaddr + memsz) {
              containingSegment = segment;
              disassemblyOutput.value += ` and selected`;
            }
            if (mmapLayout == null) {
              mmapLayout = { vaddr, memsz, offset };
            } else {
              if (vaddr + memsz > mmapLayout.vaddr + mmapLayout.memsz) {
                mmapLayout.memsz = vaddr + memsz - mmapLayout.vaddr;
              }
              if (offset + memsz > mmapLayout.offset + mmapLayout.memsz) {
                mmapLayout.memsz = offset + memsz - mmapLayout.offset;
              }
              if (vaddr < mmapLayout.vaddr) {
                mmapLayout.memsz -= mmapLayout.vaddr - vaddr;
                mmapLayout.vaddr = vaddr;
              }
              if (offset < mmapLayout.offset) {
                mmapLayout.memsz -= mmapLayout.offset - offset;
                mmapLayout.offset = offset;
              }
            }
          }

          if (!containingSegment) {
            throw new Error(`RIP 0x${rip.toString(16)} does not fall within any executable PT_LOAD segment.`);
          }
          const PF_X = 1;
          if (!(containingSegment.flags & PF_X)) {
            // For now, we'll throw an error, as we are set up to disassemble code.
            // This could be expanded later to show a hex dump of the data instead.
            throw new Error(`RIP 0x${rip.toString(16)} is in a non-executable segment (flags: ${containingSegment.flags}).\n This indicates a data access fault, not an instruction fetch fault.`);
          }
          const moduleSize = Number(faultingModule.end - faultingModule.start);
          if (!staticBinary && mmapLayout.memsz != moduleSize) {
            throw new Error(`Mmap size ${mmapLayout.memsz.toString(16)} is different than module size ${moduleSize.toString(16)}. \n Relibc load strategy may have changed.`);
          }

          let arch, mode;
          if (elf.header.machine === 62) { // EM_X86_64
            arch = cs.ARCH_X86; mode = cs.MODE_64;
          } else if (elf.header.machine === 183) { // EM_AARCH64
            arch = cs.ARCH_ARM64; mode = cs.MODE_ARM;
          } else {
            throw new Error(`Unsupported machine architecture: ${elf.header.machine}`);
          }
          const textSection = elf.sections.find(s => s.name === '.text');
          if (!textSection) {
            throw new Error("Could not find the .text section in the ELF file.");
          }
          const code = new Uint8Array(arrayBuffer, textSection.offset, textSection.size);

          // Useful for diagnostics
          console.log(window.elf = elf);

          analysisData.value = {
            runtimeSegmentStart: runtimeModuleOffset + BigInt(mmapLayout.vaddr),
            runtimeTextSectionStart: runtimeModuleOffset + BigInt(textSection.addr),
            runtimeModuleOffset,
            symbols: elf.symbols,
            file: file,
            pathModule,
            csInst: new cs.Capstone(arch, mode),
          };

          jumpAddress.value = "0x" + rip.toString(16);

          if (!analysisData.value) return;
          const { csInst, runtimeSegmentStart, runtimeTextSectionStart } = analysisData.value;
          const symbol = updateSymbolInfo(ripNum);

          successMessage.value = `Rendering view around 0x${ripNum.toString(16)}...`;

          const targetOffsetInCode = Number(targetAddrBigInt - runtimeTextSectionStart);

          if (targetOffsetInCode < 0 || targetOffsetInCode >= code.length) {
            throw new Error(`Address 0x${ripNum.toString(16)} is outside the .text section (runtime start: 0x${runtimeSegmentStart.toString(16)}, size: 0x${code.length.toString(16)}).`);
          }

          const startOffsetInData = Math.max(0, targetOffsetInCode - CONTEXT_BYTES);
          const chunkVirtualAddr = Number(runtimeSegmentStart) + startOffsetInData;
          let instructions = [];
          let currentAddr = symbol?.start || (ripNum - 500);
          const endAddr = symbol?.end || (ripNum + 500);
          let offsetInTextSection = currentAddr - Number(runtimeTextSectionStart);
          let codeChunked = code.slice(offsetInTextSection);
          while (true) {
            const safeOffset = Math.max(0, offsetInTextSection);
            const codeChunked = code.slice(safeOffset);

            let i = csInst.disasm(codeChunked, currentAddr, 1000);

            if (!i || i.length === 0) break;

            for (const insn of i) {
              if (insn.address < endAddr) {
                instructions.push(insn);
                currentAddr = insn.address + insn.size;
              } else {
                currentAddr = endAddr;
                break;
              }
            }

            const lastInsn = i[i.length - 1];
            currentAddr = lastInsn.address + lastInsn.size;

            offsetInTextSection = currentAddr - Number(runtimeTextSectionStart);
            if (currentAddr >= ripNum || instructions.length > 5000) {
              break;
            }

            const line = `\n  Seeking 0x${addd.toString(16)} ${Math.trunc((addd - Number(runtimeTextSectionStart)) / (ripNum - Number(runtimeTextSectionStart)) * 1000) / 10}%`;
            console.log(line);
            disassemblyOutput.value += line;
            await waitForNextFrame();
          }

          const minAddr = instructions[0].address;
          const maxAddr = instructions[instructions.length - 1].address;
          disassemblyOutput.value += `\n Instruction start at 0x${minAddr.toString(16)}`;
          disassemblyOutput.value += `\n Instruction end at 0x${maxAddr.toString(16)}`;
          disassemblyOutput.value += `\n looking at 0x${ripNum.toString(16)}`;

          const targetIndex = instructions.findIndex(insn => insn.address >= ripNum);
          if (targetIndex === -1) {
            throw new Error(`Could not locate instruction at or after 0x${ripNum.toString(16)}.`);
          }

          const startIndex = Math.max(0, targetIndex - LINES_BEFORE);
          const endIndex = targetIndex + LINES_AFTER + 1;
          const displayInstructions = instructions.slice(startIndex, endIndex);

          // Format for display
          let htmlOutput = '';
          for (const insn of displayInstructions) {
            const isTargetLine = insn.address === ripNum;
            const offsetStr = `0x${insn.address.toString(16).padStart(8, '0')}`;
            const bytesStr = insn.bytes.map(b => b.toString(16).padStart(2, '0')).join(' ');
            htmlOutput += `<span ${isTargetLine ? 'class="highlight" id="target-line"' : ''}>`;
            htmlOutput += `<span class="offset">${offsetStr}:</span> <span class="bytes">${bytesStr.padEnd(20)}</span> <span class="mnemonic">${insn.mnemonic}</span> ${insn.op_str}\n`;
            htmlOutput += `</span>`;
          }

          disassemblyOutput.value = htmlOutput;
          successMessage.value = `Showing ${displayInstructions.length} instructions around 0x${ripNum.toString(16)} (${file.name})`;
          if (elf.symbols.length == 0) {
            successMessage.value += " <Symbol stripped!>";
          }
          // Scroll the target line into view
          await nextTick();
          const targetLine = document.getElementById('target-line');
          if (targetLine) {
            targetLine.scrollIntoView({ behavior: 'auto', block: 'center' });
          }
        };

        const jumpToAddress = async () => {
          if (!jumpAddress.value || !analysisData.value) return;
          try {
            isLoading.value = true;
            error.value = null;
            const targetAddr = BigInt("0x" + jumpAddress.value.replace('0x', ''));
            await renderDisassemblyWindow(targetAddr);
          } catch (e) {
            error.value = e.message;
          } finally {
            isLoading.value = false;
          }
        };

        const jumpToStack = async (value) => {
          jumpAddress.value = value;
          await jumpToAddress();
        };

        const analyzeCrash = async () => {
          isLoading.value = true;
          error.value = null;
          successMessage.value = null;
          disassemblyOutput.value = 'Starting analysis...';
          callStacks.value = [];

          window.sessionStorage.faultLog = faultLog.value;
          window.sessionStorage.ldDebugLog = ldDebugLog.value;
          analysisData.value = null;

          try {
            // Parse RIP from fault log
            const ripMatch = faultLog.value.match(/(RIP|ELR_EL1):\s+([0-9a-fA-Fx]+)/);
            if (!ripMatch) throw new Error("Could not find RIP address in the page fault message.");
            const rip = BigInt('0x' + ripMatch[2]);
            disassemblyOutput.value += `\nFound RIP: 0x${rip.toString(16)}`;
            // Find more call stack
            callStacks.value.push('0x' + ripMatch[2].toLowerCase().replace(/^[0\.]+/, ""));
            for (const stackMatch of faultLog.value.matchAll(/PC\s+([0-9a-fA-Fx]+)/g)) {
              callStacks.value.push('0x' + stackMatch[1].replace(/^[0\.]+/, ""));
            }

            // Perform the initial render around the RIP
            await renderDisassemblyWindow(rip);

          } catch (e) {
            console.error("Analysis failed:", e);
            error.value = e.message || e.toString();
            disassemblyOutput.value += `\nAnalysis failed.\n\n${error.value}`;
            analysisData.value = null; // Clear context on failure
          } finally {
            isLoading.value = false;
          }
        };

        // Cleanup Capstone instance when component is unmounted
        // onUnmounted(() => { if (analysisData.value) analysisData.value.cs.close(); });

        return {
          faultLog, ldDebugLog, sysrootDirHandle, disassemblyOutput, isLoading, error,
          successMessage, isReady, analysisData, jumpAddress, currentSymbolName, currentSymbolName2, callStacks,
          selectDirectory, analyzeCrash, jumpToAddress, jumpToStack
        };
      }
    }).mount('#app');
  </script>

</body>

</html>