<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Redox Crash Analyzer</title>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --text-color: #d4d4d4;
      --primary-color: #569cd6;
      --input-bg: #252526;
      --border-color: #3e3e42;
      --error-color: #f48771;
      --success-color: #6a9955;
      --highlight-bg: #5a5a22;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 2em;
    }

    #app {
      display: grid;
      grid-template-columns: 40% 1fr;
      gap: 2em;
      height: calc(100vh - 4em);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    h1,
    h2 {
      color: var(--primary-color);
      margin-top: 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5em;
    }

    label {
      font-weight: bold;
      color: #ccc;
    }

    textarea,
    .dir-picker,
    input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      background: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 0.5em;
      font-family: "Fira Code", monospace;
    }

    textarea {
      resize: vertical;
      min-height: calc(30vh - 50px);
    }

    .dir-picker {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dir-picker span {
      opacity: 0.7;
    }

    button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.8em 1.2em;
      border-radius: 4px;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #408ac9;
    }

    button:disabled {
      background: #555;
      cursor: not-allowed;
    }

    .output-view {
      display: flex;
      flex-direction: column;
      background: var(--input-bg);
      border-radius: 4px;
      overflow: hidden;
    }

    .status {
      padding: 1em;
      text-align: center;
      border-bottom: 1px solid var(--border-color);
    }

    .jump-controls {
      display: flex;
      gap: 0.5em;
      padding: 0.5em 1em;
      border-bottom: 1px solid var(--border-color);
      background: #2a2a2d;
    }

    .error {
      color: var(--error-color);
    }

    .success {
      color: var(--success-color);
    }

    pre {
      flex-grow: 1;
      margin: 0;
      padding: 1em;
      white-space: pre;
      overflow-x: auto;
      font-family: "Fira Code", "Courier New", monospace;
      color: #9cdcfe;
    }

    .highlight {
      background-color: var(--highlight-bg);
      display: block;
    }

    .offset {
      color: #6a9955;
    }

    .bytes {
      color: #b5cea8;
    }

    .mnemonic {
      color: #c586c0;
      font-weight: bold;
    }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/@alexaltea/capstone-js@3.0.5/dist/capstone.min.js"></script>
</head>

<body>

  <div id="app">
    <div class="controls">
      <h1>Redox Crash Analyzer</h1>
      <div>
        <label for="fault-log">1. Page Fault Message</label>
        <textarea id="fault-log" v-model="faultLog" placeholder="Paste kernel log with RIP address here..."></textarea>
      </div>
      <div>
        <label for="ld-debug-log">2. LD_DEBUG Output</label>
        <textarea id="ld-debug-log" v-model="ldDebugLog"
          placeholder="Paste 'env LD_DEBUG=all ...' output here..."></textarea>
      </div>
      <div>
        <label for="sysroot-dir">3. Sysroot Directory</label>
        <div class="dir-picker">
          <span>{{ sysrootDirHandle ? sysrootDirHandle.name : 'No directory selected' }}</span>
          <button @click="selectDirectory">Select Sysroot</button>
        </div>
        <small style="opacity: 0.6;">Select the root folder containing the binaries (hint: run make mount).</small>
      </div>
      <button @click="analyzeCrash" :disabled="isLoading || !isReady">
        {{ isLoading ? 'Analyzing...' : 'Analyze Crash' }}
      </button>
    </div>

    <div class="output-view">
      <div class="status">
        <div v-if="error" class="error">{{ error }}</div>
        <div v-else-if="successMessage" class="success">{{ successMessage }}</div>
        <div v-else>Disassembly Output</div>
      </div>

      <div class="jump-controls" v-if="analysisData">
        <input type="text" v-model="jumpAddress" placeholder="0x..." @keyup.enter="jumpToAddress" />
        <button @click="jumpToAddress">Jump</button>
      </div>

      <pre v-html="disassemblyOutput"></pre>
    </div>
  </div>

  <script type="module">
    import * as elfist from 'https://unpkg.com/@wokwi/elfist@1.0.2/dist/esm/index.js';
    const { createApp, ref, computed, nextTick } = Vue;

    // --- Configuration for the disassembly window ---
    const LINES_BEFORE = 100;
    const LINES_AFTER = 100;

    // How many extra bytes to read before the target address to ensure we can disassemble `LINES_BEFORE` instructions.
    // Variable-length instructions mean we have to guess. 10 bytes per instruction is a safe overestimate.
    const CONTEXT_BYTES = LINES_BEFORE * 10;

    const alignUp = (number, alignment) => {
      return (number + alignment - 1) & -alignment;
    };
    const alignDown = (number, alignment) => {
      return number - (number % alignment);
    };

    createApp({
      setup() {
        const faultLog = ref(window.sessionStorage.faultLog || '');
        const ldDebugLog = ref(window.sessionStorage.ldDebugLog || '');
        const sysrootDirHandle = ref(null);
        const disassemblyOutput = ref('Enter the Page fault message and click "Start Analyze"');
        const isLoading = ref(false);
        const error = ref(null);
        const successMessage = ref(null);

        const isReady = computed(() => faultLog.value && ldDebugLog.value && sysrootDirHandle.value);

        const analysisData = ref(null);
        const jumpAddress = ref('');
        const selectDirectory = async () => {
          try {
            sysrootDirHandle.value = await window.showDirectoryPicker();
            error.value = null;
          } catch (err) {
            console.error("Error selecting directory:", err);
            error.value = "Failed to select directory. This feature only works on Chromium-based browsers.";
          }
        };

        const findFileInDirectory = async (dirHandle, path) => {
          if (path.startsWith('lib')) {
            path = 'usr/' + path;
          }
          const parts = path.split('/').filter(p => p && p !== '.');
          let currentHandle = dirHandle;
          for (const part of parts.slice(0, -1)) {
            currentHandle = await currentHandle.getDirectoryHandle(part, { create: false });
          }
          const fileName = parts[parts.length - 1];
          try {
            return (await currentHandle.getFileHandle(fileName, { create: false }));
          } catch (error) {
            // this is probably pointing to a symlink, but symlink is not supported here
            let files = await Array.fromAsync(currentHandle.entries());
            let file = files.find(x => x[0].startsWith(fileName));
            if (file) {
              return file[1];
            }
            throw new Error(`Can't find file ${path}.\n Chrome API does not support symlink. You might want to\n alter the path in LD_DEBUG or page fault input to fix this issue.`);
          }
        };

        const renderDisassemblyWindow = async (targetAddrBigInt) => {
          if (!analysisData.value) return;
          const { code, cs, runtimeSegmentStart, runtimeTextSectionStart, moduleBaseAddr } = analysisData.value;
          const targetAddrNum = Number(targetAddrBigInt);

          successMessage.value = `Rendering view around 0x${targetAddrNum.toString(16)}...`;

          const targetOffsetInCode = Number(targetAddrBigInt - runtimeTextSectionStart);

          if (targetOffsetInCode < 0 || targetOffsetInCode >= code.length) {
            throw new Error(`Address 0x${targetAddrNum.toString(16)} is outside the .text section (runtime start: 0x${runtimeSegmentStart.toString(16)}, size: 0x${code.length.toString(16)}).`);
          }

          const startOffsetInData = Math.max(0, targetOffsetInCode - CONTEXT_BYTES);
          const chunkVirtualAddr = Number(runtimeSegmentStart) + startOffsetInData;
          const instructions = cs.disasm(code, Number(runtimeTextSectionStart));

          const minAddr = instructions.reduce((min, x) => Math.min(min, x.address), Infinity);
          const maxAddr = instructions.reduce((max, x) => Math.max(max, x.address), 0);
          disassemblyOutput.value += `\n Instruction start at 0x${minAddr.toString(16)}`;
          disassemblyOutput.value += `\n Instruction end at 0x${maxAddr.toString(16)}`;
          disassemblyOutput.value += `\n looking at 0x${targetAddrNum.toString(16)}`;

          const targetIndex = instructions.findIndex(insn => insn.address >= targetAddrNum);
          if (targetIndex === -1) {
            throw new Error(`Could not locate instruction at or after 0x${targetAddrNum.toString(16)}.`);
          }

          const startIndex = Math.max(0, targetIndex - LINES_BEFORE);
          const endIndex = targetIndex + LINES_AFTER + 1;
          const displayInstructions = instructions.slice(startIndex, endIndex);

          // Format for display
          let htmlOutput = '';
          for (const insn of displayInstructions) {
            const isTargetLine = insn.address === targetAddrNum;
            const offsetStr = `0x${insn.address.toString(16).padStart(8, '0')}`;
            const bytesStr = insn.bytes.map(b => b.toString(16).padStart(2, '0')).join(' ');
            htmlOutput += `<span ${isTargetLine ? 'class="highlight" id="target-line"' : ''}>`;
            htmlOutput += `<span class="offset">${offsetStr}:</span> <span class="bytes">${bytesStr.padEnd(20)}</span> <span class="mnemonic">${insn.mnemonic}</span> ${insn.op_str}\n`;
            htmlOutput += `</span>`;
          }

          disassemblyOutput.value = htmlOutput;
          successMessage.value = `Showing ${displayInstructions.length} instructions around 0x${targetAddrNum.toString(16)}`;

          // Scroll the target line into view
          await nextTick();
          const targetLine = document.getElementById('target-line');
          if (targetLine) {
            targetLine.scrollIntoView({ behavior: 'auto', block: 'center' });
          }
        };

        const jumpToAddress = async () => {
          if (!jumpAddress.value || !analysisData.value) return;
          try {
            isLoading.value = true;
            error.value = null;
            const targetAddr = BigInt("0x" + jumpAddress.value.replace('0x', ''));
            await renderDisassemblyWindow(targetAddr);
          } catch (e) {
            error.value = e.message;
          } finally {
            isLoading.value = false;
          }
        };

        const analyzeCrash = async () => {
          isLoading.value = true;
          error.value = null;
          successMessage.value = null;
          disassemblyOutput.value = 'Starting analysis...';

          window.sessionStorage.faultLog = faultLog.value;
          window.sessionStorage.ldDebugLog = ldDebugLog.value;
          analysisData.value = null;

          try {
            // Parse RIP from fault log
            const ripMatch = faultLog.value.match(/RIP:\s+([0-9a-fA-Fx]+)/);
            if (!ripMatch) throw new Error("Could not find RIP address in the page fault message.");
            const rip = BigInt('0x' + ripMatch[1]);
            disassemblyOutput.value += `\nFound RIP: 0x${rip.toString(16)}`;

            // Parse memory map from LD_DEBUG
            const memoryMap = [];
            const ldLines = ldDebugLog.value.split('\n');

            let lastFoundPath = null;
            const foundAtRegex = /found at '(.*?)'/;
            const loadingObjectRegex = /loading object: (.*?) at (0x[0-9a-fA-F]+):(0x[0-9a-fA-F]+)/;

            for (const line of ldLines) {
              const foundMatch = line.match(foundAtRegex);
              if (foundMatch) {
                // Remember the full path when we see "found at..."
                lastFoundPath = foundMatch[1];
                continue; // This line is processed, move to the next
              }

              const loadingMatch = line.match(loadingObjectRegex);
              if (loadingMatch) {
                let objectPath = loadingMatch[1].split("'").join("").trim();

                // If the path from "loading object:" is not absolute (i.e., it's a short name),
                // then we must use the full path we remembered from the previous line.
                if (!objectPath.startsWith('/') && lastFoundPath) {
                  objectPath = lastFoundPath;
                }

                // Only add to the map if we have a valid path
                if (objectPath) {
                  memoryMap.push({
                    path: objectPath,
                    start: BigInt(loadingMatch[2]),
                    end: BigInt(loadingMatch[3]),
                    static: memoryMap.length == 0, // PIE false, according to relibc
                  });
                }

                // Reset the remembered path so it's not accidentally reused.
                lastFoundPath = null;
              }
            }

            let staticBinary = false;
            if (memoryMap.length === 0) {
              // assume this is static binary
              const nameRegex = /NAME ([\w\/\-]+)/;
              const nameFound = faultLog.value.match(nameRegex);
              if (nameFound) {
                const objectPath = nameFound[1];
                memoryMap.push({
                  path: objectPath,
                  start: BigInt(0),
                  end: rip, // don't bother getting a correct value
                  static: true,
                });
                staticBinary = true;
              }
            }

            if (memoryMap.length === 0) throw new Error("Could not parse any loaded objects from LD_DEBUG output.");
            disassemblyOutput.value += `\nParsed ${memoryMap.length} loaded objects.`;

            // Find the faulting module
            const faultingModule = memoryMap.find(m => rip >= m.start && rip <= m.end);
            if (!faultingModule) throw new Error(`Could not find a module containing the RIP address 0x${rip.toString(16)}.\n The code maybe loaded from mmap in the application.`);
            disassemblyOutput.value += `\nRIP is inside module: ${faultingModule.path}`;

            // Calculate offset
            const faultingModulePieFactor = BigInt(faultingModule.static ? 0 : 1); // non PIE object don't remap start offset, according to relibc
            const ripOffset = rip - faultingModule.start * faultingModulePieFactor;
            disassemblyOutput.value += `\nCalculated offset: 0x${ripOffset.toString(16)}`;
            if (faultingModule.static) {
              disassemblyOutput.value += " (unchanged because it's not PIE)";
            }

            // Find the file in the selected sysroot directory
            let pathModule = (faultingModule.path + '').replace(/^\//, ''); // Remove leading '/'

            disassemblyOutput.value += `\nSearching for ${pathModule} in sysroot...`;
            const fileHandle = await findFileInDirectory(sysrootDirHandle.value, pathModule);
            const file = await fileHandle.getFile();
            disassemblyOutput.value += `\nFound file: ${file.name}`;

            // Read and disassemble the file using elfist
            const arrayBuffer = await file.arrayBuffer();
            const elf = new elfist.ELFParser(new Uint8Array(arrayBuffer));

            // get ALL PT_LOAD segments
            const executableSegments = elf.program.filter(ph => ph.type === 1);

            if (executableSegments.length === 0) {
              throw new Error("Could not find any executable PT_LOAD segments in the ELF file.");
            }

            let mmapLayout = null, containingSegment = null;
            for (const segment of executableSegments) {
              let { align, vaddr, memsz, offset } = segment;
              // offset is usually zero on Redox GCC
              offset = alignDown(offset, align);
              memsz = alignUp(memsz + vaddr % align, align);
              vaddr = alignDown(vaddr, align);

              disassemblyOutput.value += `\nLoaded code ${vaddr.toString(16)}-${(vaddr + memsz).toString(16)}`;
              if (ripOffset >= vaddr && ripOffset < vaddr + memsz) {
                containingSegment = segment;
                disassemblyOutput.value += ` and selected`;
              }
              if (mmapLayout == null) {
                mmapLayout = { vaddr, memsz, offset };
              } else {
                if (vaddr + memsz > mmapLayout.vaddr + mmapLayout.memsz) {
                  mmapLayout.memsz = vaddr + memsz - mmapLayout.vaddr;
                }
                if (offset + memsz > mmapLayout.offset + mmapLayout.memsz) {
                  mmapLayout.memsz = offset + memsz - mmapLayout.offset;
                }
                if (vaddr < mmapLayout.vaddr) {
                  mmapLayout.memsz -= mmapLayout.vaddr - vaddr;
                  mmapLayout.vaddr = vaddr;
                }
                if (offset < mmapLayout.offset) {
                  mmapLayout.memsz -= mmapLayout.offset - offset;
                  mmapLayout.offset = offset;
                }
              }
            }

            if (!containingSegment) {
              throw new Error(`RIP 0x${rip.toString(16)} does not fall within any executable PT_LOAD segment.`);
            }
            const PF_X = 1;
            if (!(containingSegment.flags & PF_X)) {
              // For now, we'll throw an error, as we are set up to disassemble code.
              // This could be expanded later to show a hex dump of the data instead.
              throw new Error(`RIP 0x${rip.toString(16)} is in a non-executable segment (flags: ${containingSegment.flags}).\n This indicates a data access fault, not an instruction fetch fault.`);
            }
            const moduleSize = Number(faultingModule.end - faultingModule.start);
            if (!staticBinary && mmapLayout.memsz != moduleSize) {
              throw new Error(`Mmap size ${mmapLayout.memsz.toString(16)} is different than module size ${moduleSize.toString(16)}. \n Relibc load strategy may have changed.`);
            }

            const runtimeSegmentStart = faultingModule.start * faultingModulePieFactor + BigInt(mmapLayout.vaddr);

            let arch, mode;
            if (elf.header.machine === 62) { // EM_X86_64
              arch = cs.ARCH_X86; mode = cs.MODE_64;
            } else if (elf.header.machine === 183) { // EM_AARCH64
              arch = cs.ARCH_ARM64; mode = cs.MODE_ARM;
            } else {
              throw new Error(`Unsupported machine architecture: ${elf.header.machine}`);
            }
            const textSection = elf.sections.find(s => s.name === '.text');
            if (!textSection) {
              throw new Error("Could not find the .text section in the ELF file.");
            }
            const code = new Uint8Array(arrayBuffer, textSection.offset, textSection.size);
            const runtimeTextSectionStart = faultingModule.start * faultingModulePieFactor + BigInt(textSection.addr);

            // Store context for later use (jumping)
            analysisData.value = {
              code,
              runtimeSegmentStart,
              runtimeTextSectionStart,
              moduleBaseAddr: faultingModule.start,
              cs: new cs.Capstone(arch, mode),
            };

            jumpAddress.value = "0x" + rip.toString(16);

            // Perform the initial render around the RIP
            await renderDisassemblyWindow(rip);

          } catch (e) {
            console.error("Analysis failed:", e);
            error.value = e.message;
            disassemblyOutput.value += `\nAnalysis failed.\n\n${e.message}`;
            analysisData.value = null; // Clear context on failure
          } finally {
            isLoading.value = false;
          }
        };

        // Cleanup Capstone instance when component is unmounted
        // onUnmounted(() => { if (analysisData.value) analysisData.value.cs.close(); });

        return { faultLog, ldDebugLog, sysrootDirHandle, disassemblyOutput, isLoading, error, successMessage, isReady, analysisData, jumpAddress, selectDirectory, analyzeCrash, jumpToAddress };
      }
    }).mount('#app');
  </script>

</body>

</html>