<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>ELF Crash Analyzer (Virtual View)</title>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --text-color: #d4d4d4;
      --primary-color: #569cd6;
      --input-bg: #252526;
      --border-color: #3e3e42;
      --error-color: #f48771;
      --success-color: #6a9955;
      --highlight-bg: #5a5a22;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 2em;
    }

    #app {
      display: grid;
      grid-template-columns: 40% 1fr;
      gap: 2em;
      height: calc(100vh - 4em);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    h1,
    h2 {
      color: var(--primary-color);
      margin-top: 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5em;
    }

    label {
      font-weight: bold;
      color: #ccc;
    }

    textarea,
    .dir-picker,
    input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      background: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 0.5em;
      font-family: "Fira Code", monospace;
    }

    textarea {
      resize: vertical;
      min-height: 100px;
    }

    .dir-picker {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dir-picker span {
      opacity: 0.7;
    }

    button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.8em 1.2em;
      border-radius: 4px;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #408ac9;
    }

    button:disabled {
      background: #555;
      cursor: not-allowed;
    }

    .output-view {
      display: flex;
      flex-direction: column;
      background: var(--input-bg);
      border-radius: 4px;
      overflow: hidden;
    }

    .status {
      padding: 1em;
      text-align: center;
      border-bottom: 1px solid var(--border-color);
    }

    .jump-controls {
      display: flex;
      gap: 0.5em;
      padding: 0.5em 1em;
      border-bottom: 1px solid var(--border-color);
      background: #2a2a2d;
    }

    .error {
      color: var(--error-color);
    }

    .success {
      color: var(--success-color);
    }

    pre {
      flex-grow: 1;
      margin: 0;
      padding: 1em;
      white-space: pre;
      overflow-x: auto;
      font-family: "Fira Code", "Courier New", monospace;
      color: #9cdcfe;
    }

    .highlight {
      background-color: var(--highlight-bg);
      display: block;
    }

    .offset {
      color: #6a9955;
    }

    .bytes {
      color: #b5cea8;
    }

    .mnemonic {
      color: #c586c0;
      font-weight: bold;
    }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://unpkg.com/@alexaltea/capstone-js@3.0.5/dist/capstone.min.js"></script>
</head>

<body>

  <div id="app">
    <div class="controls">
      <h1>ELF Crash Analyzer</h1>
      <div>
        <label for="fault-log">1. Page Fault Message</label>
        <textarea id="fault-log" v-model="faultLog" placeholder="Paste kernel log with RIP address here..."></textarea>
      </div>
      <div>
        <label for="ld-debug-log">2. LD_DEBUG Output</label>
        <textarea id="ld-debug-log" v-model="ldDebugLog"
          placeholder="Paste 'env LD_DEBUG=all ...' output here..."></textarea>
      </div>
      <div>
        <label for="sysroot-dir">3. Sysroot Directory</label>
        <div class="dir-picker">
          <span>{{ sysrootDirHandle ? sysrootDirHandle.name : 'No directory selected' }}</span>
          <button @click="selectDirectory">Select Sysroot</button>
        </div>
        <small style="opacity: 0.6;">Select the root folder containing the binaries. Requires a secure context
          (localhost/https).</small>
      </div>
      <button @click="analyzeCrash" :disabled="isLoading || !isReady">
        {{ isLoading ? 'Analyzing...' : 'Analyze Crash' }}
      </button>
    </div>

    <div class="output-view">
      <div class="status">
        <div v-if="error" class="error">{{ error }}</div>
        <div v-else-if="successMessage" class="success">{{ successMessage }}</div>
        <div v-else>Disassembly Output</div>
      </div>

      <div class="jump-controls" v-if="analysisData">
        <input type="text" v-model="jumpAddress" placeholder="0x..." @keyup.enter="jumpToAddress" />
        <button @click="jumpToAddress">Jump</button>
      </div>

      <pre v-html="disassemblyOutput"></pre>
    </div>
  </div>

  <script type="module">
    import * as elfist from 'https://unpkg.com/@wokwi/elfist@1.0.2/dist/esm/index.js';
    const { createApp, ref, computed, nextTick } = Vue;

    // --- Configuration for the disassembly window ---
    const LINES_BEFORE = 100;
    const LINES_AFTER = 100;
    // How many extra bytes to read before the target address to ensure we can disassemble `LINES_BEFORE` instructions.
    // Variable-length instructions mean we have to guess. 10 bytes per instruction is a safe overestimate.
    const CONTEXT_BYTES = LINES_BEFORE * 10;

    createApp({
      setup() {
        const faultLog = ref(window.sessionStorage.faultLog || '');
        const ldDebugLog = ref(window.sessionStorage.ldDebugLog || '');
        const sysrootDirHandle = ref(null);
        const disassemblyOutput = ref('Waiting for analysis...');
        const isLoading = ref(false);
        const error = ref(null);
        const successMessage = ref(null);

        const isReady = computed(() => faultLog.value && ldDebugLog.value && sysrootDirHandle.value);

        // New state to hold the analysis context for jumping
        const analysisData = ref(null);
        const jumpAddress = ref('');
        const selectDirectory = async () => {
          try {
            sysrootDirHandle.value = await window.showDirectoryPicker();
            error.value = null;
          } catch (err) {
            console.error("Error selecting directory:", err);
            error.value = "Failed to select directory. This feature only works on Chromium-based browsers.";
          }
        };

        // Helper to recursively find a file handle in a directory handle
        const findFileInDirectory = async (dirHandle, path) => {
          const parts = path.split('/').filter(p => p && p !== '.');
          let currentHandle = dirHandle;
          for (const part of parts.slice(0, -1)) {
            currentHandle = await currentHandle.getDirectoryHandle(part, { create: false });
          }
          return await currentHandle.getFileHandle(parts[parts.length - 1], { create: false });
        };

        // This new function renders a small window of disassembly
        const renderDisassemblyWindow = async (targetAddrBigInt) => {
          if (!analysisData.value) return;
          const { code, cs, runtimeSegmentStart, moduleBaseAddr } = analysisData.value;
          const targetAddrNum = Number(targetAddrBigInt);

          successMessage.value = `Rendering view around 0x${targetAddrNum.toString(16)}...`;
          // 1. Calculate the REAL runtime virtual address of the .text section.
          // const runtimeTextSectionStart = moduleBaseAddr + BigInt(runtimeSegmentStart);

          // 2. Calculate the byte offset of the target address relative to the start of the .text section.
          const targetOffsetInCode = Number(targetAddrBigInt - moduleBaseAddr - runtimeSegmentStart);

          // 3. Validate that this offset is within the bounds of our .text data buffer.
          if (targetOffsetInCode < 0 || targetOffsetInCode >= code.length) {
            throw new Error(`Address 0x${targetAddrNum.toString(16)} is outside the .text section (runtime start: 0x${runtimeSegmentStart.toString(16)}, size: 0x${code.length.toString(16)}).`);
          }

          // 4. Determine the chunk of the code buffer to disassemble based on the calculated offset.
          const startOffsetInData = Math.max(0, targetOffsetInCode - CONTEXT_BYTES);
          const codeChunk = code.slice(startOffsetInData);

          // 5. The virtual address for Capstone must be the REAL runtime address of our chunk's start.
          const chunkVirtualAddr = Number(runtimeSegmentStart) + startOffsetInData;
          // 3. Disassemble only this smaller chunk
          const instructions = cs.disasm(codeChunk, Number(runtimeSegmentStart));

          // 4. Find the index of our target instruction in this new array
          const targetIndex = instructions.findIndex(insn => insn.address >= targetAddrNum);
          if (targetIndex === -1) {
            throw new Error(`Could not locate instruction at or after 0x${targetAddrNum.toString(16)}.`);
          }

          // 5. Slice the final window of instructions to display
          const startIndex = Math.max(0, targetIndex - LINES_BEFORE);
          const endIndex = targetIndex + LINES_AFTER + 1;
          const displayInstructions = instructions.slice(startIndex, endIndex);

          // 6. Format for display
          let htmlOutput = '';
          for (const insn of displayInstructions) {
            const isTargetLine = insn.address === targetAddrNum;
            const offsetStr = `0x${insn.address.toString(16).padStart(8, '0')}`;
            const bytesStr = insn.bytes.map(b => b.toString(16).padStart(2, '0')).join(' ');
            htmlOutput += `<span ${isTargetLine ? 'class="highlight" id="target-line"' : ''}>`;
            htmlOutput += `<span class="offset">${offsetStr}:</span> <span class="bytes">${bytesStr.padEnd(20)}</span> <span class="mnemonic">${insn.mnemonic}</span> ${insn.op_str}\n`;
            htmlOutput += `</span>`;
          }

          disassemblyOutput.value = htmlOutput;
          successMessage.value = `Showing ${displayInstructions.length} instructions around 0x${targetAddrNum.toString(16)}`;

          // 7. Scroll the target line into view
          await nextTick();
          const targetLine = document.getElementById('target-line');
          if (targetLine) {
            targetLine.scrollIntoView({ behavior: 'auto', block: 'center' });
          }
        };

        const jumpToAddress = async () => {
          if (!jumpAddress.value || !analysisData.value) return;
          try {
            isLoading.value = true;
            error.value = null;
            const targetAddr = BigInt("0x" + jumpAddress.value.replace('0x', ''));
            await renderDisassemblyWindow(targetAddr);
          } catch (e) {
            error.value = e.message;
          } finally {
            isLoading.value = false;
          }
        };

        const analyzeCrash = async () => {
          isLoading.value = true;
          error.value = null;
          successMessage.value = null;
          disassemblyOutput.value = 'Starting analysis...';

          window.sessionStorage.faultLog = faultLog.value;
          window.sessionStorage.ldDebugLog = ldDebugLog.value;
          analysisData.value = null; // Reset previous analysis

          try {
            // 1. Parse RIP from fault log
            const ripMatch = faultLog.value.match(/RIP:\s+([0-9a-fA-Fx]+)/);
            if (!ripMatch) throw new Error("Could not find RIP address in the page fault message.");
            const rip = BigInt('0x' + ripMatch[1]);
            disassemblyOutput.value += `\nFound RIP: 0x${rip.toString(16)}`;

            // 2. Parse memory map from LD_DEBUG
            const memoryMap = [];
            const ldLines = ldDebugLog.value.split('\n');
            const mapRegex = /loading object: (.*?) at (0x[0-9a-fA-F]+):(0x[0-9a-fA-F]+)/;
            for (const line of ldLines) {
              const match = line.match(mapRegex);
              if (match) {
                memoryMap.push({
                  path: match[1].split("'").join("").trim(), // Clean up path
                  start: BigInt(match[2]),
                  end: BigInt(match[3]),
                });
              }
            }
            if (memoryMap.length === 0) throw new Error("Could not parse any loaded objects from LD_DEBUG output.");
            disassemblyOutput.value += `\nParsed ${memoryMap.length} loaded objects.`;

            // 3. Find the faulting module
            const faultingModule = memoryMap.find(m => rip >= m.start && rip <= m.end);
            if (!faultingModule) throw new Error(`Could not find a module containing the RIP address 0x${rip.toString(16)}.`);
            disassemblyOutput.value += `\nRIP is inside module: ${faultingModule.path}`;

            // 4. Calculate offset
            const offset = rip - faultingModule.start;
            disassemblyOutput.value += `\nCalculated offset: 0x${offset.toString(16)}`;

            // 5. Find the file in the selected sysroot directory
            disassemblyOutput.value += `\nSearching for ${faultingModule.path.substring(1)} in sysroot...`;
            const fileHandle = await findFileInDirectory(sysrootDirHandle.value, faultingModule.path.substring(1)); // Remove leading '/'
            const file = await fileHandle.getFile();
            disassemblyOutput.value += `\nFound file: ${file.name}`;

            // 6. Read and disassemble the file using elfist
            const arrayBuffer = await file.arrayBuffer();
            const elf = new elfist.ELFParser(new Uint8Array(arrayBuffer));

            // Find the executable PT_LOAD segment.
            // A segment is a program header. ph.type === 1 means PT_LOAD.
            // ph.flags & 1 means the executable flag (PF_X) is set.


            // 1. Filter to get ALL executable PT_LOAD segments, not just the first one.
            const PF_X = 1;
            const executableSegments = elf.program.filter(ph => ph.type === 1 && (ph.flags & PF_X));

            if (executableSegments.length === 0) {
              throw new Error("Could not find any executable PT_LOAD segments in the ELF file.");
            }

            // The segment is relative to ELF binary
            let containingSegment = null;
            for (const segment of executableSegments) {
              let { vaddr, memsz, offset } = segment;
              // offset is usually zero on Redox GCC

              if (containingSegment == null) {
                containingSegment = { vaddr, memsz, offset };
              } else {
                if (vaddr + memsz > containingSegment.vaddr + containingSegment.memsz) {
                  containingSegment.memsz = vaddr + memsz - containingSegment.vaddr;
                }
                if (offset + memsz > containingSegment.offset + containingSegment.memsz) {
                  containingSegment.memsz = offset + memsz - containingSegment.offset;
                }
                if (vaddr < containingSegment.vaddr) {
                  containingSegment.memsz -= containingSegment.vaddr - vaddr;
                  containingSegment.vaddr = vaddr;
                }
                if (offset < containingSegment.offset) {
                  containingSegment.memsz -= containingSegment.offset - offset;
                  containingSegment.offset = offset;
                }
              }
            }

            if (!containingSegment) {
              throw new Error(`RIP 0x${rip.toString(16)} does not fall within any executable PT_LOAD segment.`);
            }

            // 3. Use the correct `containingSegment` for the rest of the logic.
            // p_filesz is the size on disk, which we use to read the bytes.
            const code = new Uint8Array(arrayBuffer, containingSegment.offset, containingSegment.filesz);

            const runtimeSegmentStart = BigInt(containingSegment.vaddr);

            let arch, mode;
            if (elf.header.machine === 62) { // EM_X86_64
              arch = cs.ARCH_X86; mode = cs.MODE_64;
            } else if (elf.header.machine === 183) { // EM_AARCH64
              arch = cs.ARCH_ARM64; mode = cs.MODE_ARM;
            } else {
              throw new Error(`Unsupported machine architecture: ${elf.header.machine}`);
            }
            // 7. Store context for later use (jumping)
            analysisData.value = {
              code,
              runtimeSegmentStart,
              cs: new cs.Capstone(arch, mode),
              moduleBaseAddr: faultingModule.start,
            };

            jumpAddress.value = "0x" + rip.toString(16);

            // 8. Perform the initial render around the RIP
            await renderDisassemblyWindow(rip);

          } catch (e) {
            console.error("Analysis failed:", e);
            error.value = e.message;
            disassemblyOutput.value = `Analysis failed.\n\n${e.message}`;
            analysisData.value = null; // Clear context on failure
          } finally {
            isLoading.value = false;
          }
        };

        // Cleanup Capstone instance when component is unmounted
        // onUnmounted(() => { if (analysisData.value) analysisData.value.cs.close(); });

        return { faultLog, ldDebugLog, sysrootDirHandle, disassemblyOutput, isLoading, error, successMessage, isReady, analysisData, jumpAddress, selectDirectory, analyzeCrash, jumpToAddress };
      }
    }).mount('#app');
  </script>

</body>

</html>